<!DOCTYPE html>
<html lang="en" class="h-full scroll-smooth" style="background-color: var(--background-color);">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pointer - Generate Game Sprites with AI</title>
    <meta name="description" content="Transform photos into game-ready character sprites using OpenAI's GPT-Image-1 model">
    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="manifest" href="./site.webmanifest">
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">
    <!-- Open Graph / Social Media Metadata -->
    <meta property="og:title" content="Pointer - Generate Game Sprites with AI">
    <meta property="og:description" content="Transform photos into game-ready character sprites using OpenAI's GPT-Image-1 model">
    <meta property="og:image" content="https://marcelontime.github.io/spriteforge/media/spriteforge.png">
    <meta property="og:url" content="https://marcelontime.github.io/spriteforge">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <!-- WhatsApp specific -->
    <meta property="og:image:width" content="1024">
    <meta property="og:image:height" content="1024">
    <meta property="og:image:alt" content="Pointer - Generate Game Sprites with AI">
    <meta property="og:image:type" content="image/png">
    <meta property="og:site_name" content="Pointer">
    <meta name="thumbnail" content="https://marcelontime.github.io/spriteforge/media/spriteforge.png">
    <meta itemprop="image" content="https://marcelontime.github.io/spriteforge/media/spriteforge.png">
    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <link rel="stylesheet" href="styles/output.css">
    <link rel="stylesheet" href="styles/main.css">
    <!-- Simple initialization script -->
    <script>
      // Initialize with clean step handling
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded - initializing wizard');
      });
    </script>
    <style>
      body {
        background: #ffffff;
        color: #1f2937;
      }
      
      .step-circle {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        color: var(--text-muted);
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
      }
      
      .step-circle.active {
        color: white;
        border-color: var(--primary-color);
      }
      
      .step-circle.completed {
        color: var(--primary-color);
        border-color: var(--primary-color);
      }
      
      .step-line {
        flex-grow: 1;
        height: 2px;
        background-color: var(--border-color);
        margin: 0 8px;
      }
      
      .step-line.active {
        background-color: var(--primary-color);
      }
      
      .style-card {
        border: 1px solid var(--border-color);
        transition: all 0.2s ease;
        background-color: var(--background-color);
        overflow: hidden;
        border-radius: 0.5rem;
        padding: 1rem;
        height: 100%;
      }
      
      .style-card:hover {
        border-color: var(--primary-color);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      
      .style-card.selected, .style-option.selected {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);
      }
      
      /* Simple Step Panel Visibility Control */
      .step-panel {
        display: none;
      }
      
      .step-panel.is-active {
        display: block;
      }
      
      /* Custom animations */
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .fade-in {
        animation: fadeIn 0.3s ease-out forwards;
      }
      
      /* Image preview styles */
      #imagePreview {
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 1rem 0;
      }
      
      #imagePreview.hidden {
        display: none;
      }
      
      #previewImage {
        max-width: 100%;
        max-height: 200px;
        border-radius: 0.5rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        object-fit: contain;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      
      #previewImage:hover {
        transform: scale(1.05);
      }
      
      :root {
        --primary-color: #007acc;
        --primary-rgb: 0, 122, 204;
        --secondary-color: #6c757d;
        --secondary-rgb: 108, 117, 125;
        --background-color: #ffffff;
        --surface-color: #f8f9fa;
        --border-color: #e9ecef;
        --text-primary: #1f2937;
        --text-secondary: #6b7280;
        --text-muted: #9ca3af;
      }
      
      /* Button Styles */
      .btn-primary {
        background-color: var(--primary-color);
        color: white;
        font-weight: 500;
        border-radius: 0.25rem;
        border: 1px solid var(--primary-color);
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      
      .btn-primary:hover {
        background-color: #0066a3;
        border-color: #0066a3;
        transform: translateY(-1px);
      }
      
      .btn-primary:disabled {
        background-color: var(--text-muted);
        border-color: var(--text-muted);
        cursor: not-allowed;
        transform: none;
      }
      
      .btn-secondary {
        background-color: var(--surface-color);
        color: var(--text-primary);
        font-weight: 500;
        border-radius: 0.25rem;
        border: 1px solid var(--border-color);
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      
      .btn-secondary:hover {
        background-color: #e2e8f0;
        border-color: var(--secondary-color);
      }
      
      .form-input {
        width: 100%;
        padding: 0.5rem 0.75rem;
        background-color: var(--background-color);
        border: 1px solid var(--border-color);
        border-radius: 0.25rem;
        color: var(--text-primary);
        font-size: 0.875rem;
        transition: border-color 0.2s;
      }
      
      .form-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.1);
      }
      
      .form-label {
        display: block;
        font-size: 0.875rem;
        font-weight: 500;
        margin-bottom: 0.5rem;
        color: var(--text-primary);
      }
      
      /* Style Grid */
      .style-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 1.5rem;
        margin-top: 2rem;
        min-height: 200px;
      }
      
      /* Selection Summary Styles */
      .selection-summary {
        background: var(--surface-color);
        border: 1px solid var(--border-color);
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
      }
      
      .selection-summary-item {
        position: relative;
        transition: transform 0.2s ease;
      }
      
      .selection-summary-item:hover {
        transform: translateY(-1px);
      }
      
      .selection-summary-image {
        width: 100px;
        height: 100px;
        border-radius: 0.25rem;
        overflow: hidden;
        background-color: var(--background-color);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        border: 2px solid transparent;
      }
      
      .selection-summary-image img {
        object-fit: contain;
        width: 100%;
        height: 100%;
      }
      
      .selection-summary-image.uploaded {
        border-color: rgba(var(--primary-rgb), 0.5);
      }
      
      .selection-summary-image.selected {
        border-color: rgba(var(--secondary-rgb), 0.5);
      }

      /* Chat Sidebar Styles */
      .chat-sidebar {
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        width: 400px;
        background: var(--surface-color);
        border-left: 1px solid var(--border-color);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
      }

      .chat-sidebar.open {
        transform: translateX(0);
      }

      .chat-toggle {
        position: fixed;
        top: 20px;
        right: 420px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 20px;
        font-weight: bold;
        z-index: 1001;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .chat-toggle:hover {
        background: #0066a3;
        transform: scale(1.05);
      }

      .chat-sidebar:not(.open) + .chat-toggle {
        right: 20px;
      }

      .chat-header {
        padding: 1rem;
        border-bottom: 1px solid var(--border-color);
        background: var(--background-color);
      }

      .chat-messages {
        flex: 1;
        font-size: 12px;
        overflow-y: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .chat-message {
        max-width: 80%;
        word-wrap: break-word;
        white-space: pre-wrap;
        line-height: 1.5;
      }

      .chat-message.user {
        align-self: flex-end;
        background: var(--primary-color);
        color: white;
        padding: 0.75rem 1rem;
        border-radius: 1rem 1rem 0.25rem 1rem;
        font-weight: 500;
      }

      .chat-message.ai {
        align-self: flex-start;
        background: var(--background-color);
        color: var(--text-primary);
        padding: 0.75rem 1rem;
        border-radius: 1rem 1rem 1rem 0.25rem;
        border: 1px solid var(--border-color);
      }

      .chat-input-container {
        padding: 1rem;
        border-top: 1px solid var(--border-color);
        background: var(--background-color);
      }

      .chat-input-wrapper {
        display: flex;
        gap: 0.5rem;
        align-items: flex-end;
      }

      .chat-input {
        flex: 1;
        background: var(--background-color);
        border: 1px solid var(--border-color);
        border-radius: 1rem;
        padding: 0.75rem 1rem;
        color: var(--text-primary);
        resize: none;
        min-height: 90px;
        max-height: 120px;
        font-size: 12px;
        line-height: 1.5;
      }

      .chat-input::placeholder {
        font-size: 12px;
      }

      .chat-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.1);
      }

      .chat-send-btn {
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: bold;
      }

      .chat-send-btn:hover:not(:disabled) {
        background: #0066a3;
        transform: scale(1.05);
      }

      .chat-send-btn:disabled {
        background: var(--text-muted);
        cursor: not-allowed;
      }

      .typing-indicator {
        align-self: flex-start;
        background: var(--surface-color);
        color: var(--text-secondary);
        padding: 0.75rem 1rem;
        border-radius: 1rem 1rem 1rem 0.25rem;
        border: 1px solid var(--border-color);
        font-style: italic;
        display: none;
        font-size: 12px;
        margin-bottom:10px;
        margin-left:10px;
      }

      .typing-indicator.show {
        display: block;
      }

      /* Responsive adjustments */
      @media (max-width: 640px) {
        .chat-sidebar {
          width: 100vw;
        }
        
        .chat-sidebar.open + .chat-toggle {
          right: 20px;
        }
      }

      /* Ensure main content doesn't get covered */
      body.chat-open {
        margin-right: 0;
      }

      @media (min-width: 1024px) {
        body.chat-open .container {
          margin-right: 420px;
          transition: margin-right 0.3s ease-in-out;
        }
      }

      @media (min-width: 768px) and (max-width: 1023px) {
        body.chat-open .container {
          margin-right: 420px;
          transition: margin-right 0.3s ease-in-out;
        }
      }

      /* Navigation Header Styles */
      .navbar {
        position: sticky;
        top: 0;
        z-index: 999;
        background-color: var(--background-color);
        border-bottom: 1px solid var(--border-color);
        backdrop-filter: blur(8px);
      }

      .navbar-brand {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-primary);
        text-decoration: none;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .navbar-brand:hover {
        color: var(--primary-color);
        transform: translateY(-1px);
      }

      .navbar-brand::before {
        content: "●";
        color: var(--primary-color);
        font-size: 1.25rem;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      /* ===== Page Styling ===== */

      /* Reference Images Upload Component Styles */
      .reference-images-panel {
        margin-bottom: 2rem;
      }

      .reference-upload-area {
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        padding: 2rem;
        text-align: center;
        transition: all 0.3s ease;
        background-color: var(--surface-color);
        cursor: pointer;
      }

      .reference-upload-area:hover {
        border-color: var(--primary-color);
        background-color: var(--background-color);
      }

      .reference-upload-area.drag-over {
        border-color: var(--primary-color);
        background-color: rgba(59, 130, 246, 0.1);
        transform: scale(1.02);
      }

      .reference-upload-icon {
        color: var(--text-muted);
        margin-bottom: 1rem;
        display: flex;
        justify-content: center;
      }

      .reference-upload-title {
        color: var(--text-primary);
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .reference-upload-subtitle {
        color: var(--text-secondary);
        font-size: 0.875rem;
        margin-bottom: 1.5rem;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
      }

      .reference-upload-actions {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
      }

      .reference-upload-or {
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      .reference-images-grid {
        margin-top: 1.5rem;
      }

      .reference-images-header {
        margin-bottom: 1rem;
      }

      .reference-images-header h4 {
        color: var(--text-primary);
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
      }

      .reference-thumbnails {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 0.75rem;
        max-height: 120px;
        overflow-y: auto;
      }

      .reference-thumbnail {
        position: relative;
        aspect-ratio: 1;
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid var(--border-color);
        background-color: var(--surface-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .reference-thumbnail:hover {
        border-color: var(--primary-color);
        transform: scale(1.05);
      }

      .reference-thumbnail img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .reference-thumbnail-remove {
        position: absolute;
        top: 2px;
        right: 2px;
        width: 16px;
        height: 16px;
        background-color: rgba(239, 68, 68, 0.9);
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .reference-thumbnail:hover .reference-thumbnail-remove {
        opacity: 1;
      }

      .reference-thumbnail-remove:hover {
        background-color: rgba(220, 38, 38, 1);
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .reference-upload-area {
          padding: 1.5rem;
        }
        
        .reference-thumbnails {
          grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body class="h-full antialiased chat-open" style="color: var(--text-primary);">
    <!-- Helper functions -->
    <script>
      // showImageModal function removed as requested
      
      // API key is loaded from environment configuration in state.js
      // No need to manually load from localStorage
    </script>
    
    <!-- Navigation Header -->
    <nav class="navbar">
      <div class="container mx-auto px-4 py-3 flex items-center justify-between max-w-5xl">
        <a href="#" class="navbar-brand" onclick="window.location.reload()">
          Pointer
        </a>
      </div>
    </nav>

    <div class="container mx-auto px-4 py-8 max-w-5xl" style="background-color: var(--background-color);">
      <!-- Main header -->
      <header class="text-center mb-12 pt-4">
        <h1 class="text-4xl sm:text-6xl font-extrabold mb-6" style="color: var(--text-primary);">
          Turn character descriptions into<br />
          <span style="color: var(--primary-color);">game-ready sprites</span>
        </h1>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
          <!-- Buttons removed -->
        </div>
      </header>
      
      <!-- Step indicator - progression tracker -->
      <!-- <div class="flex items-center justify-center mb-12 max-w-sm mx-auto" id="stepper">
        <div class="step flex items-center" data-step="1">
          <div class="step-circle active flex items-center justify-center w-8 h-8 rounded-full text-sm font-medium">1</div>
          <div class="ml-2 mr-auto text-sm font-medium" style="color: var(--primary-color);">Describe</div>
        </div>
        
        <div class="h-0.5 w-20 mx-3 step-line"></div>
        
        <div class="step flex items-center" data-step="2">
          <div class="step-circle flex items-center justify-center w-8 h-8 rounded-full text-sm font-medium">2</div>
          <div class="ml-2 text-sm font-medium" style="color: var(--text-muted);">Actions</div>
        </div>
      </div> -->
      
      <!-- Main content -->
      <main class="relative">
        <!-- STEP 1 – Describe -->
        <section data-step="1" class="step-panel is-active" id="describe">
          <!-- Reference Images Upload Component -->
          <div class="reference-images-panel">
            <div class="reference-upload-area" id="referenceUploadArea">
              <div class="reference-upload-content">
                <div class="reference-upload-icon">
                  <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="9" cy="9" r="2"/>
                    <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>
                  </svg>
                </div>
                <h3 class="reference-upload-title">Upload Reference Images Here</h3>
                <p class="reference-upload-subtitle">Create a unified visual aesthetic to inform the design of all game assets</p>
                <div class="reference-upload-actions">
                  <button type="button" class="btn-secondary" id="referenceSelectBtn">
                    Select Images
                  </button>
                  <span class="reference-upload-or">or drag and drop here</span>
                </div>
              </div>
              <input type="file" id="referenceFileInput" multiple accept="image/*" style="display: none;">
            </div>
            
            <!-- Reference Images Grid -->
            <div class="reference-images-grid" id="referenceImagesGrid" style="display: none;">
              <div class="reference-images-header">
                <h4>Reference Images</h4>
                <p class="text-sm text-gray-400">Visual branding and aesthetic of these images will inform generations</p>
              </div>
              <div class="reference-thumbnails" id="referenceThumbnails">
                <!-- Thumbnails will be dynamically added here -->
              </div>
            </div>
          </div>

          <!-- Top action navigation -->
          <div class="flex items-center justify-between mb-8">
            <!-- Buttons removed -->
          </div>
          
          <!-- Character Generation Placeholder -->
          <div class="flex justify-center mb-6 p-20" id="placeholderBox">
            <div class="w-half max-w-2xl p-20">
              <div class="rounded-lg p-20 flex flex-col items-center justify-center min-h-[400px]" style="background-color: var(--surface-color); border: 1px solid var(--border-color);">
                <div class="text-center w-half p-20">
                  <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mb-8 mx-auto" style="color: var(--text-muted); padding-top:20px;" fill="none" width="50px" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                </svg>
                  
                  <div class="text-3xl font-medium mb-6" style="color: var(--text-muted);">
                    Generate your character
              </div>
              
                  <p class="text-base" style="color: var(--text-secondary);padding:20px">
                    Use the AI Assistant to describe your character and generate sprites
                  </p>
            </div>
              </div>
            </div>
          </div>
          
          <!-- API Key (hidden - loaded from environment) -->
          <div class="mb-8" style="display: none;">
            <form id="apiKeyForm" onsubmit="event.preventDefault();" autocomplete="off">
              <input type="text" id="apiUsername" name="username" style="display: none;" autocomplete="username" value="openai" />
              <label for="apiKey" class="form-label">OpenAI API Key</label>
              <input type="password" id="apiKey" name="apiKey" class="form-input" placeholder="sk-..." autocomplete="new-password" data-lpignore="true" />
            </form>
          </div>
          

          
          <!-- Navigation -->
          <div class="flex justify-center" style="display: none;">
            <button id="toStep2" class="btn-primary px-8 py-3">Continue to Actions →</button>
          </div>
        </section>
        
        <!-- STEP 2 – Actions -->
        <section data-step="2" class="step-panel" id="actions">
          <!-- Reference Images Upload Component -->
          <div class="reference-images-panel">
            <div class="reference-upload-area" id="referenceUploadArea2">
              <div class="reference-upload-content">
                <div class="reference-upload-icon">
                  <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="9" cy="9" r="2"/>
                    <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>
                  </svg>
                </div>
                <h3 class="reference-upload-title">Upload Reference Images Here</h3>
                <p class="reference-upload-subtitle">Create a unified visual aesthetic to inform the design of all game assets</p>
                <div class="reference-upload-actions">
                  <button type="button" class="btn-secondary" id="referenceSelectBtn2">
                    Select Images
                  </button>
                  <span class="reference-upload-or">or drag and drop here</span>
                </div>
              </div>
              <input type="file" id="referenceFileInput2" multiple accept="image/*" style="display: none;">
            </div>
            
            <!-- Reference Images Grid -->
            <div class="reference-images-grid" id="referenceImagesGrid2" style="display: none;">
              <div class="reference-images-header">
                <h4>Reference Images</h4>
                <p class="text-sm text-gray-400">Visual branding and aesthetic of these images will inform generations</p>
              </div>
              <div class="reference-thumbnails" id="referenceThumbnails2">
                <!-- Thumbnails will be dynamically added here -->
              </div>
            </div>
          </div>

          <!-- Top action navigation -->
          <div class="flex items-center justify-between mb-8">
            <button type="button" class="btn-secondary px-6 py-3 rounded-md" data-back="1">← Back</button>
          </div>
          
          <!-- Character Preview and Action Selection -->
          <div class="flex flex-col md:flex-row gap-6 mb-6">
            <!-- Left side - Character Preview -->
            <div class="w-full md:w-1/2 rounded-lg p-4 flex flex-col items-center justify-center min-h-[200px]" style="background-color: var(--surface-color); border: 1px solid var(--border-color);">
              <h3 class="text-lg font-semibold mb-4" style="color: var(--text-primary);">Your Character</h3>
              <div id="styledImageContainer" class="w-full flex items-center justify-center">
                <img id="styledImagePreview" class="max-h-48 max-w-full rounded shadow object-contain" alt="Character Preview" />
              </div>
            </div>
            
            <!-- Right side - Action Selection -->
            <div class="w-full md:w-1/2 rounded-lg p-4 flex flex-col" style="background-color: var(--surface-color); border: 1px solid var(--border-color);">
              <h3 class="text-lg font-semibold mb-4" style="color: var(--text-primary);">Choose Action</h3>
              
              <!-- Action selection dropdown -->
              <div class="mb-4">
                <label for="actionSelect" class="form-label">Animation Type</label>
                <select id="actionSelect" class="form-input">
                  <option value="" disabled selected>Select action...</option>
                  <!-- Options will be populated from ACTION_PROMPTS -->
                </select>
              </div>
              
              <!-- Action description will be shown here -->
              <div id="actionDescription" class="text-sm mb-4" style="color: var(--text-secondary);">
                Select an action to see its description and frame count.
              </div>
              
              <!-- Generate button -->
              <button id="generateActionBtn" class="btn-primary w-full py-3 mt-auto" disabled>
                Generate Action
              </button>
            </div>
          </div>
          
          <!-- Animation Preview Section - Simplified -->
          <div class="rounded-lg p-6 mb-8" style="background-color: var(--surface-color); border: 1px solid var(--border-color);">
            <h3 class="text-xl font-semibold mb-4" style="color: var(--text-primary);">Action Preview</h3>
            
            <!-- Preview Area -->
            <div id="actionPreview" class="flex justify-center items-center min-h-[200px] rounded-lg mb-4 hidden" style="background-color: var(--background-color);">
              <!-- Preview content will be inserted here -->
            </div>
            
            <!-- Generated Frames Grid -->
            <div id="actionFramesContainer" class="mt-4">
              <!-- Frame grid will be inserted here -->
            </div>
          </div>
        </section>
      </main>
      
      <!-- Footer -->
      <footer class="text-center text-sm mt-16 pb-8" style="color: var(--text-muted);">
        Built by the team &nbsp;·&nbsp; <a href="https://github.com/marcelontime/spriteforge" class="underline hover:opacity-70" style="color: var(--text-muted);">GitHub</a>
      </footer>
    </div>
    
    <!-- Image Modal removed as requested -->
    
    <!-- Chat Sidebar -->
    <div id="chatSidebar" class="chat-sidebar open">
      <div class="chat-header">
        <h3 class="text-lg font-semibold" style="color: var(--text-primary);">AI Assistant</h3>
        <p class="text-sm" style="color: var(--text-secondary);">Ask me anything about sprite generation!</p>
      </div>
      
      <div id="chatMessages" class="chat-messages">
        <div class="chat-message ai">
          <div>Welcome to Pointer! I'm here to help you create amazing game sprites from character descriptions.

To get started, describe your character in detail. The more specific you are, the better your sprite will be! Here are some examples:

• A brave knight in shining armor with a blue cape and golden sword
• A mystical forest elf with emerald robes, pointed ears, and a magical bow
• A cyberpunk hacker with neon-lit goggles, dark clothing, and glowing tattoos
• A friendly dragon with colorful scales, small wings, and a cheerful expression

Tell me about your character's appearance, clothing, accessories, and style. What kind of sprite would you like to create?</div>
        </div>
      </div>
      
      <div class="typing-indicator" id="typingIndicator">
        Thinking...
      </div>
      
      <div class="chat-input-container">
        <div class="chat-input-wrapper">
          <textarea 
            id="chatInput" 
            class="chat-input" 
            placeholder="Describe your character. For example, 'dog wearing sunglasses.'"
            rows="3"
          ></textarea>
          <button id="chatSendBtn" class="chat-send-btn" title="Send message">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Chat Toggle Button -->
    <button id="chatToggle" class="chat-toggle" title="Toggle AI Assistant">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
      </svg>
    </button>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script type="module" src="js/config.js"></script>
    <script type="module" src="js/state.js"></script>
    <script type="module" src="js/api.js"></script>
    <script type="module" src="js/chatRouter.js"></script>
    <script type="module" src="js/ui.js"></script>
    <script type="module" src="js/wizard.js"></script>
    <script>
      // Basic event handlers
      document.addEventListener('DOMContentLoaded', function() {
        // Modal functionality removed as requested
        
        // API key is now loaded from environment configuration
        // No need for input handling since key is loaded from .env.local
        
        // Character generation is now handled through AI chat
        // No form validation needed for the placeholder box
        
        // Initialize reference images system
        initReferenceImages();
        
        // Chat functionality (wizard.js handles step initialization)
        initializeChat();
        
        // Listen for character generation events
        document.addEventListener('characterGenerated', handleCharacterGenerated);
        
        // Set initial chat placeholder based on current step
        setTimeout(() => {
          const currentStep = getCurrentStepFromURL();
          updateChatPlaceholder(currentStep);
        }, 100);
        
        // Listen for URL changes to update placeholder
        window.addEventListener('popstate', () => {
          setTimeout(() => {
            const currentStep = getCurrentStepFromURL();
            updateChatPlaceholder(currentStep);
          }, 100);
        });
        
        // Also listen for pushstate events (manual navigation)
        const originalPushState = history.pushState;
        history.pushState = function() {
          originalPushState.apply(history, arguments);
          setTimeout(() => {
            const currentStep = getCurrentStepFromURL();
            updateChatPlaceholder(currentStep);
          }, 100);
        };
      });

              /**
         * Handles character generation events from the chat system
         */
        function handleCharacterGenerated(event) {
          console.log('🎯 Character generated event received:', event.detail);
          
          const { imageUrl, navigateToStep2 } = event.detail;
          
          if (navigateToStep2) {
            // Store the image globally
            window.generatedCharacterUrl = imageUrl;
            
            // Wait a bit for wizard to be fully loaded, then navigate
            setTimeout(() => {
              // Try to use URL navigation to trigger wizard step change
              const url = new URL(window.location);
              url.searchParams.set('step', '2');
              window.history.pushState({}, '', url);
              
              // Trigger a popstate event to make wizard react to URL change
              window.dispatchEvent(new PopStateEvent('popstate'));
              
              // Also try to find and click the step 2 navigation if available
              const step2Panel = document.querySelector('[data-step="2"]');
              if (step2Panel) {
                // Force show step 2 panel
                document.querySelectorAll('.step-panel').forEach(panel => {
                  panel.classList.remove('is-active');
                  panel.style.display = 'none';
                });
                
                step2Panel.classList.add('is-active');
                step2Panel.style.display = 'block';
                
                // Set up the character image
                setTimeout(() => {
                  const styledImagePreview = document.getElementById('styledImagePreview');
                  if (styledImagePreview && imageUrl) {
                    styledImagePreview.src = imageUrl;
                    styledImagePreview.style.width = '200px';
                    styledImagePreview.style.height = '200px';
                    styledImagePreview.style.objectFit = 'contain';
                    console.log('✅ Character image set in step 2');
                  }
                  
                  // Update chat placeholder for step 2
                  updateChatPlaceholder(2);
                  
                  // Initialize action selection
                  initializeStep2ActionSelection();
                }, 100);
              }
              
              console.log('✅ Navigated to step 2');
            }, 100);
          }
        }

        /**
         * Gets current step from URL parameter
         */
        function getCurrentStepFromURL() {
          const urlParams = new URLSearchParams(window.location.search);
          return parseInt(urlParams.get('step')) || 1;
        }

        /**
         * Updates chat input placeholder text based on current step
         */
        function updateChatPlaceholder(step) {
          const chatInput = document.getElementById('chatInput');
          if (chatInput) {
            if (step === 1) {
              chatInput.placeholder = "Describe your character. For example, 'dog wearing sunglasses.'";
            } else if (step === 2) {
              chatInput.placeholder = "Type your text here";
            }
            console.log(`📝 Chat placeholder updated for step ${step}`);
          }
        }

        /**
         * Initializes action selection for step 2
         */
        async function initializeStep2ActionSelection() {
          console.log('🎯 [DEBUG] initializeStep2ActionSelection called from index.html');
          
          try {
            const actionSelect = document.getElementById('actionSelect');
            if (!actionSelect) {
              console.warn('❌ [DEBUG] Action select element not found');
              return;
            }
            
            console.log('🔧 [DEBUG] Found actionSelect element:', actionSelect);
            console.log('🔧 [DEBUG] Current options before clear:', actionSelect.options.length);
            
            // Clear existing options except the placeholder
            while (actionSelect.options.length > 1) {
              actionSelect.remove(1);
            }
            
            console.log('🔧 [DEBUG] Options after clear:', actionSelect.options.length);
            
            // Force populate with actions even if we don't have proper state
            // This ensures the dropdown always has options for the AI routing system
            const actions = {
              'idle': { name: 'Idle Animation', frames: 4, basePrompt: 'Character in neutral standing pose with subtle breathing motion' },
              'walk': { name: 'Walking Animation', frames: 12, basePrompt: 'Character walking cycle with natural arm and leg movement' },
              'jump': { name: 'Jump Animation', frames: 4, basePrompt: 'Character performing a vertical jump sequence' },
              'air_attack': { name: 'Air Attack', frames: 2, basePrompt: 'Character executing a mid-air attack move' },
              'hurt': { name: 'Hurt Animation', frames: 2, basePrompt: 'Character taking damage and recoiling' },
              'knock_out': { name: 'Knock Out', frames: 6, basePrompt: 'Character being defeated and falling down' },
              'punches': { name: 'Punch Combo', frames: 8, basePrompt: 'Character performing various punch attacks' },
              'turn_around': { name: 'Turn Around', frames: 3, basePrompt: 'Character turning around 180 degrees' }
            };
            
            console.log(`🔧 [DEBUG] Force populating dropdown with ${Object.keys(actions).length} actions`);
            
            // Add actions to select
            Object.entries(actions).forEach(([actionId, actionData]) => {
              console.log(`🔧 [DEBUG] Adding action: ${actionId} - ${actionData.name}`);
              const option = document.createElement('option');
              option.value = actionId;
              option.textContent = actionData.name;
              option.dataset.frames = actionData.frames;
              option.dataset.description = actionData.basePrompt;
              actionSelect.appendChild(option);
            });
            
            console.log('🔧 [DEBUG] Final options after population:', actionSelect.options.length);
            
            // Add change event listener if not already added
            if (!actionSelect.dataset.listenerAdded) {
              actionSelect.addEventListener('change', function() {
                console.log('🔧 [DEBUG] Action selection changed to:', this.value);
                const selectedOption = this.options[this.selectedIndex];
                const actionDescription = document.getElementById('actionDescription');
                const generateActionBtn = document.getElementById('generateActionBtn');
                
                if (selectedOption && selectedOption.value) {
                  if (actionDescription) {
                    actionDescription.innerHTML = `
                      <p class="font-medium">${selectedOption.textContent}</p>
                      <p class="text-sm mt-1">${selectedOption.dataset.description}</p>
                      <p class="text-xs mt-2 opacity-75">Frames: ${selectedOption.dataset.frames}</p>
                    `;
                    console.log('✅ [DEBUG] Updated action description');
                  }
                  
                  if (generateActionBtn) {
                    generateActionBtn.disabled = false;
                    console.log('✅ [DEBUG] Enabled generate button');
                  }
                } else {
                  if (actionDescription) {
                    actionDescription.textContent = 'Select an action to see its description and frame count.';
                    console.log('🔧 [DEBUG] Reset action description');
                  }
                  
                  if (generateActionBtn) {
                    generateActionBtn.disabled = true;
                    console.log('🔧 [DEBUG] Disabled generate button');
                  }
                }
              });
              actionSelect.dataset.listenerAdded = 'true';
            }
            
            console.log('✅ [DEBUG] Action selection initialized from index.html');
            
          } catch (error) {
            console.error('❌ [DEBUG] Error initializing action selection from index.html:', error);
          }
        }

        /**
         * Test function to manually populate action dropdown for debugging
         */
        window.testPopulateActions = async function() {
          console.log('🧪 [TEST] Testing manual action population');
          
          const actionSelect = document.getElementById('actionSelect');
          if (!actionSelect) {
            console.error('❌ [TEST] Action select not found');
            return;
          }
          
          console.log('🧪 [TEST] ActionSelect found, current options:', actionSelect.options.length);
          
          // Manual test data
          const testActions = {
            'idle': { name: 'Idle Animation', frames: 4, basePrompt: 'Character in neutral standing pose' },
            'walk': { name: 'Walking Animation', frames: 12, basePrompt: 'Character walking cycle' },
            'jump': { name: 'Jump Animation', frames: 4, basePrompt: 'Character performing a vertical jump' }
          };
          
          // Clear existing options except placeholder
          while (actionSelect.options.length > 1) {
            actionSelect.remove(1);
          }
          
          // Add test options
          Object.entries(testActions).forEach(([actionId, actionData]) => {
            console.log(`🧪 [TEST] Adding test action: ${actionId}`);
            const option = document.createElement('option');
            option.value = actionId;
            option.textContent = actionData.name;
            option.dataset.frames = actionData.frames;
            option.dataset.description = actionData.basePrompt;
            actionSelect.appendChild(option);
          });
          
          console.log('🧪 [TEST] Test population complete, options:', actionSelect.options.length);
          return actionSelect.options.length;
        };

      /**
       * Handles the next button functionality - integrates with existing wizard system
       */
      function handleNextClick() {
        console.log('🚀 Next clicked');
        
        // Get the generated character image URL
        const generatedImage = document.querySelector('#placeholderBox img');
        if (generatedImage && generatedImage.src) {
          // Store character image globally for wizard access
          window.generatedCharacterUrl = generatedImage.src;
          
          // Create a custom event to notify the wizard system
          const characterReadyEvent = new CustomEvent('characterGenerated', {
            detail: {
              imageUrl: generatedImage.src,
              navigateToStep2: true
            }
          });
          
          // Dispatch the event
          document.dispatchEvent(characterReadyEvent);
          
          console.log('✅ Character ready event dispatched');
        } else {
          console.error('❌ No generated character image found');
        }
      }

      // Navigation functions removed - using event-based system
      
      // Chat functionality
      function initializeChat() {
        const chatToggle = document.getElementById('chatToggle');
        const chatSidebar = document.getElementById('chatSidebar');
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatMessages = document.getElementById('chatMessages');
        const typingIndicator = document.getElementById('typingIndicator');
        
        // Load chat history from localStorage
        loadChatHistory();
        
        // Toggle chat sidebar
        chatToggle.addEventListener('click', function() {
          const isOpen = chatSidebar.classList.contains('open');
          if (isOpen) {
            chatSidebar.classList.remove('open');
            document.body.classList.remove('chat-open');
          } else {
            chatSidebar.classList.add('open');
            document.body.classList.add('chat-open');
            // Focus on input when opened
            setTimeout(() => chatInput.focus(), 300);
          }
        });
        
        // Auto-resize textarea
        chatInput.addEventListener('input', function() {
          this.style.height = 'auto';
          this.style.height = Math.min(this.scrollHeight, 120) + 'px';
          
          // Enable/disable send button
          chatSendBtn.disabled = !this.value.trim();
        });
        
        // Send message on Enter (without Shift)
        chatInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });
        
        // Send message on button click
        chatSendBtn.addEventListener('click', sendMessage);
        
        async function sendMessage() {
          const message = chatInput.value.trim();
          if (!message) return;
          
          console.log('📨 Sending message:', message);
          
          // Add user message
          addMessage(message, 'user');
          
          // Clear input
          chatInput.value = '';
          chatInput.style.height = 'auto';
          chatSendBtn.disabled = true;
          
          // Show typing indicator
          showTypingIndicator();
          
          try {
            // Generate AI response using the new routing system
            console.log('🤖 Generating AI response with routing...');
            const aiResponse = await generateAIResponse(message);
            console.log('✅ AI response generated:', aiResponse);
            
            hideTypingIndicator();
            addMessage(aiResponse, 'ai');
          } catch (error) {
            console.error('❌ Error generating AI response:', error);
            hideTypingIndicator();
            addMessage("I apologize, but I encountered an error processing your request. Please try again.", 'ai');
          }
        }
        
        function addMessage(text, sender) {
          const messageDiv = document.createElement('div');
          messageDiv.className = `chat-message ${sender}`;
          messageDiv.innerHTML = `<div>${escapeHtml(text)}</div>`;
          
          chatMessages.appendChild(messageDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;
          
          // Save to localStorage
          saveChatHistory();
        }
        
        function showTypingIndicator() {
          typingIndicator.classList.add('show');
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function hideTypingIndicator() {
          typingIndicator.classList.remove('show');
        }
        
        async function generateAIResponse(userMessage) {
          console.log('🎯 generateAIResponse called with message:', userMessage);
          
          try {
            // Check what step we're currently on
            const currentStep = getCurrentStep();
            console.log('📍 Current step:', currentStep);
            
            // If on step 1, bypass routing and generate character
            if (currentStep === 1) {
              console.log('🎨 Step 1 detected - bypassing routing, generating character');
              return await handleStep1CharacterGeneration(userMessage);
            }
            
            // For other steps, use the normal routing system
            const { routeUserMessage } = await import('./js/chatRouter.js');
            
            // Route the message and get the category
            console.log('🔀 Routing user message through chatRouter');
            const category = await routeUserMessage(userMessage);
            console.log('📋 Routing completed, category:', category);
            
            // Generate response based on the routed category
            return generateCategoryResponse(category, userMessage);
          } catch (error) {
            console.error('❌ Error in generateAIResponse:', error);
            return "I apologize, but I encountered an error processing your request. Please try again or check the console for more details.";
          }
        }
        
        // Make generateAIResponse globally accessible
        window.generateAIResponse = generateAIResponse;
        
        /**
         * Determines the current step the user is on
         * @returns {number} - Current step number (1 or 2)
         */
        function getCurrentStep() {
          // Check which step panel has the 'is-active' class
          const activeStepPanel = document.querySelector('.step-panel.is-active');
          if (activeStepPanel) {
            const stepAttr = activeStepPanel.getAttribute('data-step');
            return parseInt(stepAttr) || 1;
          }
          
          // Fallback: check step indicator
          const activeStepCircle = document.querySelector('.step-circle.active');
          if (activeStepCircle) {
            const parentStep = activeStepCircle.closest('[data-step]');
            if (parentStep) {
              return parseInt(parentStep.getAttribute('data-step')) || 1;
            }
          }
          
          // Default to step 1
          return 1;
        }
        
        // Make getCurrentStep globally accessible
        window.getCurrentStep = getCurrentStep;
        
        /**
         * Handles character generation for step 1
         * @param {string} userMessage - The user's character description
         * @returns {Promise<string>} - Response message
         */
        async function handleStep1CharacterGeneration(userMessage) {
          console.log('🎨 Starting character generation');
          console.log('📝 User prompt:', userMessage);
          
          try {
            // Import the DALL-E 3 function
            const { callDALLE3 } = await import('./js/api.js');
            
            // Enhance the user's prompt for better sprite generation
            const enhancedPrompt = `Generate an image of a video game character sprite with a solid white background. The details of the character: ${userMessage}. The character should be suitable for a 2D game, with clear details and vibrant colors. Style: digital art, game sprite, clean design. Generate just a SINGLE character with no other background and no other elements.
            GENERATE A SINGLE CHARACTER. ONE CHARACTER. ONE. ONE CHARACTER ONLY. NOTHING ELSE.`;
            
            console.log('🔄 Enhanced prompt:', enhancedPrompt);
            
            // Call API to generate the character
            console.log('📡 Calling generation API...');
            const imageUrl = await callDALLE3(enhancedPrompt);
            console.log('✅ Character generation complete');
            
            // Replace the placeholder box with the generated image
            replaceCharacterPlaceholder(imageUrl);
            
            // Enable the continue button
            enableContinueButton();
            
            return "Perfect! I've generated your character. You can see the result in the main panel above. If you like, I can generate a different version, just say the word. When you're ready, click 'Next' to proceed to the animation step.";
            
          } catch (error) {
            console.error('❌ Error in character generation:', error);
            return `Sorry, I encountered an error generating your character: ${error.message}. Please try again with a different description.`;
          }
        }
        
        /**
         * Replaces the character placeholder box with the generated image
         * @param {string} imageUrl - Data URL of the generated image
         */
        function replaceCharacterPlaceholder(imageUrl) {
          console.log('🖼️ Replacing placeholder with generated image');
          
          // Store the generated image URL globally for step 2
          window.generatedCharacterUrl = imageUrl;
          
          const placeholderContainer = document.getElementById('placeholderBox');
          if (placeholderContainer) {
            placeholderContainer.innerHTML = `
              <div class="w-half max-w-2xl p-20">
                <!-- Top Next Button -->
                <div class="w-full flex justify-center mb-6">
                  ${createNextButton('nextBtn-top', 'btn-primary px-8 py-3')}
                </div>
                
                <!-- Generated Character Image -->
                <div class="rounded-lg p-8 flex flex-col items-center justify-center" style="background-color: var(--surface-color); border: 1px solid var(--border-color);">
                  <div class="bg-white rounded-lg p-4 shadow-lg">
                    <img src="${imageUrl}" 
                         alt="Generated Character" 
                         style="width: 200px; height: 200px;"
                         class="w-[200px] h-[200px] object-contain rounded" />
                  </div>
                </div>
                
                <!-- Bottom Next Button -->
                <div class="w-full flex justify-center mt-6">
                  ${createNextButton('nextBtn-bottom', 'btn-primary px-8 py-3')}
                </div>
              </div>
            `;
            console.log('✅ Placeholder replaced successfully with dual continue buttons');
          } else {
            console.error('❌ Could not find placeholder container');
          }
        }
        
        /**
         * Creates a reusable next button component
         * @param {string} id - Unique ID for the button
         * @param {string} classes - Additional CSS classes
         * @returns {string} - HTML string for the button
         */
        function createNextButton(id = 'nextBtn', classes = 'btn-primary px-8 py-3') {
          return `<button id="${id}" class="${classes}" onclick="handleNextClick()">Next</button>`;
        }

        // Navigation functions moved to global scope

        /**
         * Enables all next buttons for proceeding to step 2
         */
        function enableContinueButton() {
          const nextButtons = document.querySelectorAll('[id*="nextBtn"], #toStep2');
          nextButtons.forEach(btn => {
            if (btn) {
              btn.disabled = false;
              btn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
          });
          
          // Hide any extra buttons that might be added by other scripts
          const extraButtons = document.querySelectorAll('button');
          extraButtons.forEach(btn => {
            if (btn.textContent.includes('Next') && 
                !btn.id.includes('nextBtn') && 
                btn.id !== 'toStep2' &&
                btn.id !== 'chatSendBtn') {
              btn.style.display = 'none';
            }
          });
          
          console.log('✅ Next buttons enabled');
        }
        
        function generateCategoryResponse(category, originalMessage) {
          console.log('💬 Generating response for category:', category);
          
          const currentStep = window.getCurrentStep();
          console.log('📍 Current step when generating response:', currentStep);
          
          // If we're on step 2 and the category is an animation, trigger action generation
          if (currentStep === 2 && category !== 'character' && category !== 'unknown') {
            console.log('🎬 Step 2 animation request detected, triggering action generation for:', category);
            return handleStep2ActionGeneration(category, originalMessage);
          }
          
          switch (category) {
            case 'character':
              return "I can help you create a character sprite! Based on your description, I'll generate a unique character. Please provide more details about your character's appearance, clothing, and style, and I'll create a sprite for you.";
              
            case 'idle':
              return "Great! I can generate an idle animation for your character. This will create a 4-frame breathing animation that shows your character in a natural standing pose. The animation will be ready for use in your game.";
              
            case 'walk':
              return "Perfect! I can create a walking animation cycle for your character. This will be a smooth 12-frame animation showing natural walking movement with proper arm and leg coordination.";
              
            case 'jump':
              return "Excellent! I can generate a jumping animation for your character. This will be a 4-frame sequence showing the crouch, launch, peak, and landing phases of a jump.";
              
            case 'air_attack':
              return "Nice! I can create an air attack animation for your character. This will be a 2-frame aerial combat move that shows your character executing a powerful mid-air strike.";
              
            case 'hurt':
              return "I can generate a hurt animation for your character. This will be a 2-frame reaction animation showing your character taking damage and recoiling from impact.";
              
            case 'knock_out':
              return "I can create a knockout animation for your character. This will be a 6-frame dramatic sequence showing your character being defeated and falling to the ground.";
              
            case 'punches':
              return "Great choice! I can generate a punch combination animation for your character. This will be an 8-frame sequence showing various punch attacks including jabs, hooks, and uppercuts.";
              
            case 'turn_around':
              return "I can create a turn around animation for your character. This will be a 3-frame sequence showing your character smoothly changing direction with a 180-degree turn.";
              
            case 'unknown':
            default:
              return "I'm here to help with sprite generation! You can:\n• Describe a character you want me to create\n• Ask for specific animations like 'walking', 'jumping', 'punching'\n• Request help with art styles or game sprite creation\n\nWhat would you like to work on?";
          }
        }
        
        /**
         * Handles action generation for step 2 animation requests
         * @param {string} actionCategory - The action category from routing
         * @param {string} originalMessage - The original user message
         * @returns {Promise<string>} - Response message
         */
        async function handleStep2ActionGeneration(actionCategory, originalMessage) {
          console.log('🎬 Starting step 2 action generation for category:', actionCategory);
          console.log('🎬 Original message:', originalMessage);
          
          try {
            // Import state management functions
            const { getState, updateState } = await import('./js/state.js');
            
            // Check current state
            let state = getState();
            console.log('🔍 Initial state:', state);
            
            // For testing purposes, if we're missing required state data, add mock data
            if (!state.selectedStyle || !state.uploadedImage) {
              console.warn('⚠️ Missing required state data for step 2. Adding mock data for testing...');
              
              // Create a mock uploaded image (1x1 pixel transparent PNG)
              const mockImageBlob = new Blob([new Uint8Array([
                0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
                0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4,
                0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
                0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE,
                0x42, 0x60, 0x82
              ])], { type: 'image/png' });
              
              const mockImageFile = new File([mockImageBlob], 'mock-image.png', { type: 'image/png' });
              
              // Update state with mock data
              const stateUpdate = {
                uploadedImage: mockImageFile,
                selectedStyle: 'original', // Use original style for testing
                selectedAction: actionCategory // Also set the selected action
              };
              
              updateState(stateUpdate);
              
              console.log('✅ Mock state data added:', stateUpdate);
              
              // Verify state was updated
              state = getState();
              console.log('🔍 State after mock data update:', {
                hasUploadedImage: !!state.uploadedImage,
                selectedStyle: state.selectedStyle,
                selectedAction: state.selectedAction
              });
            }
            
            // First, automatically select the action in the dropdown
            const success = await autoSelectAction(actionCategory);
            if (!success) {
              return `I understand you want to create a ${actionCategory} animation, but I couldn't find that action in the available options. Please select an action from the dropdown manually.`;
            }
            
            // Give the selection a moment to register and verify dropdown state
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Double-check the dropdown value after selection
            const actionSelect = document.getElementById('actionSelect');
            const dropdownValue = actionSelect ? actionSelect.value : null;
            console.log('🔧 [DEBUG] Dropdown value after auto-selection:', dropdownValue);
            
            // Additional debugging for dropdown state
            if (actionSelect) {
              console.log('🔧 [DEBUG] Detailed dropdown state after selection:', {
                value: actionSelect.value,
                selectedIndex: actionSelect.selectedIndex,
                optionsCount: actionSelect.options.length,
                selectedOption: actionSelect.options[actionSelect.selectedIndex] ? {
                  value: actionSelect.options[actionSelect.selectedIndex].value,
                  text: actionSelect.options[actionSelect.selectedIndex].text,
                  selected: actionSelect.options[actionSelect.selectedIndex].selected
                } : null,
                allOptionsSelected: Array.from(actionSelect.options).map(opt => ({
                  value: opt.value,
                  text: opt.text,
                  selected: opt.selected
                }))
              });
            }
            
            // Update state with the selected action to ensure consistency
            updateState({ selectedAction: dropdownValue || actionCategory });
            
            // Wait a bit more to ensure state is updated
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Final state verification before triggering generation
            state = getState();
            console.log('🔍 [DEBUG] Final state before generation:', {
              selectedStyle: state.selectedStyle,
              selectedAction: state.selectedAction,
              dropdownValue: dropdownValue,
              hasUploadedImage: !!state.uploadedImage,
              hasGeneratedCharacter: !!window.generatedCharacterUrl
            });
            
            // Check for any mismatches between state and dropdown
            if (state.selectedAction !== dropdownValue) {
              console.warn('⚠️ [DEBUG] State/dropdown mismatch detected:', {
                stateAction: state.selectedAction,
                dropdownValue: dropdownValue,
                attempting: 'sync correction'
              });
              
              // Try to sync them
              if (dropdownValue && dropdownValue !== '') {
                updateState({ selectedAction: dropdownValue });
                console.log('🔧 [DEBUG] Updated state to match dropdown');
              } else if (state.selectedAction) {
                actionSelect.value = state.selectedAction;
                console.log('🔧 [DEBUG] Updated dropdown to match state');
              }
            }
            
            // Validate that we have everything needed
            if (!state.selectedStyle) {
              console.error('❌ [DEBUG] Missing selectedStyle in state');
              return `I couldn't find a selected style. Please ensure you have a character generated or a style selected.`;
            }
            
            if (!dropdownValue || dropdownValue === '') {
              console.error('❌ [DEBUG] Missing action selection in dropdown');
              return `I couldn't select the ${actionCategory} action in the dropdown. Please try selecting it manually.`;
            }
            
            // Now trigger the generation by clicking the button
            const success2 = await triggerActionGeneration();
            if (!success2) {
              return `I've selected the ${actionCategory} action for you, but couldn't trigger the generation automatically. Please click the "Generate Action" button to create your animation.`;
            }
            
            return `Starting ${actionCategory} animation generation. You can watch the progress in the preview area below.`;
            
          } catch (error) {
            console.error('❌ Error in handleStep2ActionGeneration:', error);
            return `I encountered an error while trying to generate the ${actionCategory} animation: ${error.message}. Please try selecting the action manually from the dropdown.`;
          }
        }

        /**
         * Automatically selects the specified action in the dropdown
         * @param {string} actionCategory - The action category to select
         * @returns {Promise<boolean>} - True if selection was successful
         */
        async function autoSelectAction(actionCategory) {
          console.log('🎯 [DEBUG] Auto-selecting action:', actionCategory);
          
          // First, ensure step 2 is properly initialized
          console.log('🔧 [DEBUG] Checking step 2 initialization before selection...');
          const isInitialized = await window.debugStep2Initialization();
          
          if (!isInitialized) {
            console.error('❌ [DEBUG] Step 2 is not properly initialized, cannot proceed with action selection');
            return false;
          }
          
          const actionSelect = document.getElementById('actionSelect');
          if (!actionSelect) {
            console.error('❌ [DEBUG] Action select dropdown not found');
            return false;
          }
          
          console.log('🔧 [DEBUG] Initial dropdown state:', {
            optionsCount: actionSelect.options.length,
            currentValue: actionSelect.value,
            selectedIndex: actionSelect.selectedIndex,
            options: Array.from(actionSelect.options).map(opt => ({ value: opt.value, text: opt.text }))
          });
          
          // Wait for dropdown to be populated if it's empty
          if (actionSelect.options.length <= 1) {
            console.log('⏳ [DEBUG] Dropdown appears empty, waiting for population...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Check again
            if (actionSelect.options.length <= 1) {
              console.log('⏳ [DEBUG] Still empty, trying to populate manually...');
              
              // Try to trigger the population manually
              if (typeof initializeStep2ActionSelection === 'function') {
                await initializeStep2ActionSelection();
                await new Promise(resolve => setTimeout(resolve, 500));
              }
              
              // Final check
              if (actionSelect.options.length <= 1) {
                console.error('❌ [DEBUG] Dropdown still empty after manual population');
                return false;
              }
            }
          }
          
          // Create mapping of natural language to dropdown values
          const actionMappings = {
            // Direct mappings
            'idle': 'idle',
            'walk': 'walk', 
            'jump': 'jump',
            'air_attack': 'air_attack',
            'hurt': 'hurt',
            'knock_out': 'knock_out',
            'punches': 'punches',
            'turn_around': 'turn_around',
            
            // Alternative names and synonyms
            'walking': 'walk',
            'run': 'walk',
            'running': 'walk',
            'movement': 'walk',
            'move': 'walk',
            
            'jumping': 'jump',
            'leap': 'jump',
            'hop': 'jump',
            
            'aerial': 'air_attack',
            'air': 'air_attack',
            'flying': 'air_attack',
            'airborne': 'air_attack',
            'mid-air': 'air_attack',
            'diving': 'air_attack',
            
            'damage': 'hurt',
            'pain': 'hurt',
            'hit': 'hurt',
            'injury': 'hurt',
            'recoil': 'hurt',
            
            'knockout': 'knock_out',
            'ko': 'knock_out',
            'defeat': 'knock_out',
            'death': 'knock_out',
            'collapse': 'knock_out',
            'fall': 'knock_out',
            'falling': 'knock_out',
            
            'punch': 'punches',
            'fight': 'punches',
            'fighting': 'punches',
            'combat': 'punches',
            'attack': 'punches',
            'boxing': 'punches',
            'melee': 'punches',
            'strike': 'punches',
            'striking': 'punches',
            
            'turn': 'turn_around',
            'rotate': 'turn_around',
            'rotation': 'turn_around',
            'spin': 'turn_around',
            'spinning': 'turn_around',
            'pivot': 'turn_around',
            
            'breathing': 'idle',
            'standing': 'idle',
            'rest': 'idle',
            'resting': 'idle'
          };
          
          // Get the mapped value or use the original category
          const actionValue = actionMappings[actionCategory.toLowerCase()] || actionCategory.toLowerCase();
          console.log('🔄 [DEBUG] Mapped category to value:', actionCategory, '→', actionValue);
          
          // Debug: Show all available options before trying to match
          console.log('🔧 [DEBUG] Available dropdown options before matching:', 
            Array.from(actionSelect.options).map((opt, index) => ({
              index: index,
              value: opt.value,
              text: opt.text,
              selected: opt.selected
            }))
          );
          
          // Try to find the action in the dropdown
          let found = false;
          let selectedOptionValue = null;
          let matchedOptionIndex = -1;
          
          for (let i = 0; i < actionSelect.options.length; i++) {
            const option = actionSelect.options[i];
            const optionValue = option.value.toLowerCase();
            const optionText = option.text.toLowerCase();
            
            // Skip placeholder/empty options
            if (!option.value || option.value === '' || option.value === 'placeholder') {
              console.log('🔧 [DEBUG] Skipping placeholder option:', { value: option.value, text: option.text });
              continue;
            }
            
            console.log('🔧 [DEBUG] Checking option:', {
              index: i,
              value: option.value,
              text: option.text,
              optionValueLower: optionValue,
              optionTextLower: optionText,
              searchValue: actionValue,
              exactValueMatch: optionValue === actionValue,
              textIncludesSearch: optionText.includes(actionValue),
              searchIncludesValue: actionValue.includes(optionValue)
            });
            
            // Check for exact value match, text match, or partial text match
            if (optionValue === actionValue || 
                optionText.includes(actionValue) ||
                actionValue.includes(optionValue)) {
              
              console.log('✅ [DEBUG] Found matching option:', { 
                index: i,
                value: option.value, 
                text: option.text,
                matchType: optionValue === actionValue ? 'exact value' : 
                          optionText.includes(actionValue) ? 'text includes' : 'partial match'
              });
              
              selectedOptionValue = option.value;
              matchedOptionIndex = i;
              
              // Set the value with multiple approaches
              console.log('🔧 [DEBUG] Setting dropdown value (before):', {
                value: actionSelect.value,
                selectedIndex: actionSelect.selectedIndex
              });
              
              // Approach 1: Set by value
              actionSelect.value = option.value;
              console.log('🔧 [DEBUG] After setting by value:', {
                value: actionSelect.value,
                selectedIndex: actionSelect.selectedIndex
              });
              
              // Approach 2: Set by selectedIndex (backup)
              if (actionSelect.value !== option.value) {
                console.warn('⚠️ [DEBUG] Setting by value failed, trying selectedIndex');
                actionSelect.selectedIndex = i;
                console.log('🔧 [DEBUG] After setting by selectedIndex:', {
                  value: actionSelect.value,
                  selectedIndex: actionSelect.selectedIndex
                });
              }
              
              // Approach 3: Force selection (if still not working)
              if (actionSelect.value !== option.value) {
                console.warn('⚠️ [DEBUG] Both approaches failed, forcing selection');
                option.selected = true;
                console.log('🔧 [DEBUG] After forcing selection:', {
                  value: actionSelect.value,
                  selectedIndex: actionSelect.selectedIndex,
                  optionSelected: option.selected
                });
              }
              
              found = true;
              break;
            }
          }
          
          // If we found a match, trigger events and handle button state
          if (found && selectedOptionValue) {
            console.log('🔧 [DEBUG] Match found, triggering events and checking button state...');
            
            // Trigger multiple events to ensure selection is registered
            console.log('🔧 [DEBUG] Triggering events...');
            
            // First dispatch change event
            const changeEvent = new Event('change', { bubbles: true });
            actionSelect.dispatchEvent(changeEvent);
            console.log('🔧 [DEBUG] Dispatched change event');
            
            // Also trigger input event
            const inputEvent = new Event('input', { bubbles: true });
            actionSelect.dispatchEvent(inputEvent);
            console.log('🔧 [DEBUG] Dispatched input event');
            
            // Give the event handlers time to process
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Verify the selection actually worked
            console.log('🔧 [DEBUG] Final dropdown state after selection:', {
              value: actionSelect.value,
              selectedIndex: actionSelect.selectedIndex,
              expectedValue: selectedOptionValue,
              matchedIndex: matchedOptionIndex,
              selectionWorked: actionSelect.value === selectedOptionValue
            });
            
            // Check if the button state changed
            const generateBtn = document.getElementById('generateActionBtn');
            if (generateBtn) {
              console.log('🔧 [DEBUG] Generate button state after selection:', {
                disabled: generateBtn.disabled,
                exists: true
              });
              
              // If button is still disabled, try to manually enable it
              if (generateBtn.disabled) {
                console.warn('⚠️ [DEBUG] Button still disabled after selection, force enabling...');
                generateBtn.disabled = false;
                console.log('✅ [DEBUG] Manually enabled generate button');
              }
            } else {
              console.warn('⚠️ [DEBUG] Generate button not found after selection');
            }
          }
          
          if (!found) {
            console.error('❌ [DEBUG] Could not find action in dropdown:', actionCategory);
            console.log('🔧 [DEBUG] Available options:', Array.from(actionSelect.options).map(opt => ({ value: opt.value, text: opt.text })));
            console.log('🔧 [DEBUG] Tried to match:', actionValue);
            return false;
          }
          
          // Final verification that the selection worked
          const finalValue = actionSelect.value;
          const success = finalValue === selectedOptionValue && finalValue !== '' && finalValue !== null;
          
          console.log('🔍 [DEBUG] Final selection verification:', {
            selectedOptionValue: selectedOptionValue,
            actualDropdownValue: finalValue,
            success: success,
            isEmpty: finalValue === '' || finalValue === null
          });
          
          if (!success) {
            console.error('❌ [DEBUG] Dropdown selection failed verification');
            return false;
          }
          
          console.log('✅ [DEBUG] Action selected successfully:', finalValue);
          return true;
        }

        /**
         * Triggers the action generation by clicking the generate button
         * @returns {Promise<boolean>} - True if trigger was successful
         */
        async function triggerActionGeneration() {
          console.log('🚀 [DEBUG] Triggering action generation...');
          
          const generateBtn = document.getElementById('generateActionBtn');
          if (!generateBtn) {
            console.error('❌ [DEBUG] Generate action button not found');
            return false;
          }
          
          console.log('🔧 [DEBUG] Button state before any changes:', {
            disabled: generateBtn.disabled,
            textContent: generateBtn.textContent.trim(),
            className: generateBtn.className
          });
          
          // Comprehensive validation before clicking
          const actionSelect = document.getElementById('actionSelect');
          if (!actionSelect) {
            console.error('❌ [DEBUG] Action select dropdown not found');
            return false;
          }
          
          console.log('🔧 [DEBUG] Dropdown state before button click:', {
            value: actionSelect.value,
            selectedIndex: actionSelect.selectedIndex,
            selectedOption: actionSelect.options[actionSelect.selectedIndex] ? {
              value: actionSelect.options[actionSelect.selectedIndex].value,
              text: actionSelect.options[actionSelect.selectedIndex].text
            } : null,
            hasValue: !!actionSelect.value && actionSelect.value !== '',
            isEmpty: actionSelect.value === '' || actionSelect.value === null
          });
          
          // Check state management
          try {
            const { getState } = await import('./js/state.js');
            const state = getState();
            console.log('🔍 [DEBUG] State before button click:', {
              selectedStyle: state.selectedStyle,
              selectedAction: state.selectedAction,
              hasUploadedImage: !!state.uploadedImage,
              hasGeneratedCharacter: !!window.generatedCharacterUrl
            });
          } catch (error) {
            console.warn('⚠️ [DEBUG] Could not check state:', error);
          }
          
          // Check if button is disabled and try to force enable it
          if (generateBtn.disabled) {
            console.warn('⚠️ [DEBUG] Generate button is disabled, attempting to force enable...');
            
            // Force enable the button
            generateBtn.disabled = false;
            
            console.log('🔧 [DEBUG] Forced button to enabled state');
            
            // Also verify that we have an action selected
            if (!actionSelect.value || actionSelect.value === '') {
              console.error('❌ [DEBUG] No action selected in dropdown, this might be why button was disabled');
              
              // Try to re-select if we have a selected action in state
              try {
                const { getState } = await import('./js/state.js');
                const state = getState();
                if (state.selectedAction) {
                  console.log('🔧 [DEBUG] Attempting to re-select action from state:', state.selectedAction);
                  actionSelect.value = state.selectedAction;
                  
                  // Trigger change event
                  const changeEvent = new Event('change', { bubbles: true });
                  actionSelect.dispatchEvent(changeEvent);
                  
                  await new Promise(resolve => setTimeout(resolve, 100));
                  console.log('🔧 [DEBUG] Re-selected action, new value:', actionSelect.value);
                }
              } catch (error) {
                console.warn('⚠️ [DEBUG] Could not re-select action:', error);
              }
            }
            
            // Trigger change event to ensure everything is updated
            const changeEvent = new Event('change', { bubbles: true });
            actionSelect.dispatchEvent(changeEvent);
            console.log('🔧 [DEBUG] Triggered change event on action dropdown');
            
            // Give it a moment to process
            await new Promise(resolve => setTimeout(resolve, 200));
          }
          
          // Final validation before clicking
          console.log('🔍 [DEBUG] Final validation before clicking button:', {
            buttonDisabled: generateBtn.disabled,
            dropdownValue: actionSelect.value,
            dropdownHasValue: !!actionSelect.value && actionSelect.value !== '',
            readyToClick: !generateBtn.disabled && actionSelect.value && actionSelect.value !== ''
          });
          
          if (generateBtn.disabled) {
            console.error('❌ [DEBUG] Button is still disabled even after force enable attempt');
            return false;
          }
          
          if (!actionSelect.value || actionSelect.value === '') {
            console.error('❌ [DEBUG] Dropdown still has no value even after attempts to fix it');
            return false;
          }
          
          // Trigger the click event
          console.log('✅ [DEBUG] Clicking generate button...');
          generateBtn.click();
          
          // Wait a moment and check what happened
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Check if button state changed (indicating it was clicked)
          const buttonStateAfterClick = {
            disabled: generateBtn.disabled,
            textContent: generateBtn.textContent.trim(),
            isLoading: generateBtn.textContent.includes('Generating') || generateBtn.textContent.includes('Loading')
          };
          
          console.log('🔍 [DEBUG] Button state after click:', buttonStateAfterClick);
          
          const clickSuccessful = buttonStateAfterClick.isLoading || buttonStateAfterClick.disabled;
          
          console.log('✅ [DEBUG] Button click result:', {
            clicked: true,
            indicatesSuccess: clickSuccessful,
            explanation: clickSuccessful ? 'Button shows loading state or is disabled (expected)' : 'Button state unchanged (possible error)'
          });
          
          return true;
        }

        function saveChatHistory() {
          const messages = [];
          chatMessages.querySelectorAll('.chat-message').forEach(msg => {
            const isUser = msg.classList.contains('user');
            const text = msg.querySelector('div').textContent;
            messages.push({ text, sender: isUser ? 'user' : 'ai' });
          });
          localStorage.setItem('spriteforge_chat_history', JSON.stringify(messages));
        }
        
        function loadChatHistory() {
          const history = localStorage.getItem('spriteforge_chat_history');
          if (history) {
            const messages = JSON.parse(history);
            // Clear existing messages except the welcome message
            const welcomeMessage = chatMessages.querySelector('.chat-message.ai');
            chatMessages.innerHTML = '';
            if (welcomeMessage) {
              chatMessages.appendChild(welcomeMessage);
            }
            
            // Add saved messages
            messages.forEach(msg => {
              if (msg.text && msg.sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${msg.sender}`;
                messageDiv.innerHTML = `<div>${escapeHtml(msg.text)}</div>`;
                chatMessages.appendChild(messageDiv);
              }
            });
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
        }
        
        function escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        // Initialize step 2 action selection when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
          console.log('🎯 DOM loaded, checking for step 2 initialization');
          
          // Check if we're on step 2 and initialize the dropdown
          setTimeout(() => {
            const currentStep = window.getCurrentStep();
            console.log('📍 Current step on DOM ready:', currentStep);
            
            if (currentStep === 2) {
              console.log('🎯 Step 2 detected, initializing action selection...');
              initializeStep2ActionSelection();
            }
          }, 1000);
        });
        
        // Also check periodically if step 2 becomes active
        setInterval(() => {
          const currentStep = window.getCurrentStep();
          const actionSelect = document.getElementById('actionSelect');
          
          if (currentStep === 2 && actionSelect && actionSelect.options.length <= 1) {
            console.log('🎯 Step 2 detected with empty dropdown, initializing...');
            initializeStep2ActionSelection();
          }
        }, 2000);
      }

      /**
       * Comprehensive test function to debug AI routing flow
       */
      window.testAIRouting = async function(testMessage = "generate a walking animation") {
        console.log('🎯 [TEST] Starting AI routing test with message:', testMessage);
        
        try {
          // Import state management functions
          const { getState, updateState } = await import('./js/state.js');
          
          // Step 1: Check current step
          const currentStep = window.getCurrentStep();
          console.log('📍 [TEST] Current step:', currentStep);
          
          // Step 2: Check if we're on step 2
          if (currentStep !== 2) {
            console.log('⚠️ [TEST] Not on step 2, test may not work correctly');
          }
          
          // Step 3: Check dropdown state
          const actionSelect = document.getElementById('actionSelect');
          console.log('🔧 [TEST] Dropdown state:', {
            exists: !!actionSelect,
            optionsCount: actionSelect ? actionSelect.options.length : 0,
            currentValue: actionSelect ? actionSelect.value : null,
            options: actionSelect ? Array.from(actionSelect.options).map(opt => opt.value) : []
          });
          
          // Step 4: Initialize dropdown if needed
          if (!actionSelect || actionSelect.options.length <= 1) {
            console.log('🔧 [TEST] Initializing dropdown...');
            await initializeStep2ActionSelection();
          }
          
          // Step 5: Check state
          const state = getState();
          console.log('🔍 [TEST] Current state:', {
            hasSelectedStyle: !!state.selectedStyle,
            hasUploadedImage: !!state.uploadedImage,
            selectedStyle: state.selectedStyle
          });
          
          // Step 6: Test AI response generation
          console.log('🤖 [TEST] Testing AI response generation...');
          const aiResponse = await generateAIResponse(testMessage);
          console.log('✅ [TEST] AI response:', aiResponse);
          
          // Step 7: Check if generation was triggered
          const generateBtn = document.getElementById('generateActionBtn');
          console.log('🔧 [TEST] Generate button state:', {
            exists: !!generateBtn,
            disabled: generateBtn ? generateBtn.disabled : null,
            text: generateBtn ? generateBtn.textContent.trim() : null
          });
          
          console.log('🎉 [TEST] AI routing test completed successfully!');
          return aiResponse;
          
        } catch (error) {
          console.error('❌ [TEST] AI routing test failed:', error);
          return `Test failed: ${error.message}`;
        }
      };

      /**
       * Test all animation types with various natural language prompts
       */
      window.testAllAnimations = async function() {
        console.log('🧪 [TEST] Starting comprehensive animation type tests');
        
        const testCases = [
          // Idle variations
          { prompt: "create an idle animation", expected: "idle" },
          { prompt: "make my character breathe", expected: "idle" },
          { prompt: "generate a standing animation", expected: "idle" },
          
          // Walk variations  
          { prompt: "create a walking animation", expected: "walk" },
          { prompt: "make my character run", expected: "walk" },
          { prompt: "generate movement frames", expected: "walk" },
          
          // Jump variations
          { prompt: "create a jumping animation", expected: "jump" },
          { prompt: "make my character leap", expected: "jump" },
          { prompt: "generate a hop animation", expected: "jump" },
          
          // Air attack variations
          { prompt: "create an air attack", expected: "air_attack" },
          { prompt: "make an aerial strike", expected: "air_attack" },
          { prompt: "generate a flying attack", expected: "air_attack" },
          
          // Hurt variations
          { prompt: "create a hurt animation", expected: "hurt" },
          { prompt: "make a damage reaction", expected: "hurt" },
          { prompt: "generate a pain animation", expected: "hurt" },
          
          // Knockout variations
          { prompt: "create a knockout animation", expected: "knock_out" },
          { prompt: "make a defeat sequence", expected: "knock_out" },
          { prompt: "generate a falling animation", expected: "knock_out" },
          
          // Punch variations
          { prompt: "create punch animations", expected: "punches" },
          { prompt: "make fighting moves", expected: "punches" },
          { prompt: "generate combat attacks", expected: "punches" },
          
          // Turn around variations
          { prompt: "create a turn around animation", expected: "turn_around" },
          { prompt: "make my character spin", expected: "turn_around" },
          { prompt: "generate a rotation animation", expected: "turn_around" }
        ];
        
        console.log(`🔄 Testing ${testCases.length} animation variations...`);
        
        const results = [];
        
        for (let i = 0; i < testCases.length; i++) {
          const testCase = testCases[i];
          console.log(`\n🧪 Test ${i+1}/${testCases.length}: "${testCase.prompt}"`);
          
          try {
            // Import the router function
            const { routeUserMessage } = await import('./js/chatRouter.js');
            
            // Test the routing
            const category = await routeUserMessage(testCase.prompt);
            const success = category === testCase.expected;
            
            results.push({
              prompt: testCase.prompt,
              expected: testCase.expected,
              actual: category,
              success: success
            });
            
            console.log(`${success ? '✅' : '❌'} Expected: ${testCase.expected}, Got: ${category}`);
            
            // Small delay between tests
            await new Promise(resolve => setTimeout(resolve, 200));
            
          } catch (error) {
            console.error(`❌ Test failed:`, error);
            results.push({
              prompt: testCase.prompt,
              expected: testCase.expected,
              actual: 'ERROR',
              success: false,
              error: error.message
            });
          }
        }
        
        // Summary
        const successCount = results.filter(r => r.success).length;
        const totalCount = results.length;
        
        console.log(`\n📊 TEST RESULTS SUMMARY:`);
        console.log(`✅ Successful: ${successCount}/${totalCount} (${Math.round(successCount/totalCount*100)}%)`);
        console.log(`❌ Failed: ${totalCount - successCount}`);
        
        // Show failed tests
        const failures = results.filter(r => !r.success);
        if (failures.length > 0) {
          console.log(`\n❌ FAILED TESTS:`);
          failures.forEach(f => {
            console.log(`   "${f.prompt}" → Expected: ${f.expected}, Got: ${f.actual}`);
          });
        }
        
        return results;
      };

      /**
       * Simple test function to trigger the problematic workflow
       */
      window.debugWalkingAnimation = async function() {
        console.log('🧪 [DEBUG TEST] Starting walking animation debug test');
        
        // Simulate the user typing "create a walking animation"
        const testMessage = "create a walking animation";
        
        // Add the message to the chat to simulate real usage
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          const userMessageDiv = document.createElement('div');
          userMessageDiv.className = 'chat-message user';
          userMessageDiv.innerHTML = `<div>${testMessage}</div>`;
          chatMessages.appendChild(userMessageDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        console.log('🧪 [DEBUG TEST] Simulating user message:', testMessage);
        
        try {
          // Call the main AI response function (use window scope to access it)
          const response = await window.generateAIResponse(testMessage);
          
          // Add AI response to chat
          if (chatMessages) {
            const aiMessageDiv = document.createElement('div');
            aiMessageDiv.className = 'chat-message ai';
            aiMessageDiv.innerHTML = `<div>${response}</div>`;
            chatMessages.appendChild(aiMessageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
          
          console.log('🧪 [DEBUG TEST] AI response:', response);
          console.log('🧪 [DEBUG TEST] Test completed successfully');
          
          return response;
        } catch (error) {
          console.error('🧪 [DEBUG TEST] Test failed:', error);
          return `Test failed: ${error.message}`;
        }
      };

      /**
       * Test function to check dropdown state at any time
       */
      window.debugDropdownState = function() {
        console.log('🔍 [DEBUG] Current dropdown state check:');
        
        const actionSelect = document.getElementById('actionSelect');
        if (!actionSelect) {
          console.error('❌ [DEBUG] Action select dropdown not found');
          return;
        }
        
        console.log('🔧 [DEBUG] Dropdown details:', {
          value: actionSelect.value,
          selectedIndex: actionSelect.selectedIndex,
          optionsCount: actionSelect.options.length,
          allOptions: Array.from(actionSelect.options).map((opt, index) => ({
            index: index,
            value: opt.value,
            text: opt.text,
            selected: opt.selected
          })),
          hasValue: !!actionSelect.value && actionSelect.value !== '',
          isEmpty: actionSelect.value === '' || actionSelect.value === null
        });
        
        // Also check state
        try {
          import('./js/state.js').then(({ getState }) => {
            const state = getState();
            console.log('🔍 [DEBUG] Current state:', {
              selectedStyle: state.selectedStyle,
              selectedAction: state.selectedAction,
              hasUploadedImage: !!state.uploadedImage
            });
          });
        } catch (error) {
          console.warn('⚠️ [DEBUG] Could not check state:', error);
        }
      };

      /**
       * Test function to manually select an action and see if it works
       */
      window.debugManualSelection = async function(actionValue = 'walk') {
        console.log('🧪 [DEBUG MANUAL] Testing manual action selection:', actionValue);
        
        const actionSelect = document.getElementById('actionSelect');
        if (!actionSelect) {
          console.error('❌ [DEBUG MANUAL] Action select dropdown not found');
          return false;
        }
        
        console.log('🔧 [DEBUG MANUAL] Before selection:', {
          value: actionSelect.value,
          selectedIndex: actionSelect.selectedIndex,
          optionsCount: actionSelect.options.length
        });
        
        // Try the selection
        actionSelect.value = actionValue;
        
        console.log('🔧 [DEBUG MANUAL] After setting value:', {
          value: actionSelect.value,
          selectedIndex: actionSelect.selectedIndex,
          worked: actionSelect.value === actionValue
        });
        
        // Trigger change event
        const changeEvent = new Event('change', { bubbles: true });
        actionSelect.dispatchEvent(changeEvent);
        
        console.log('🔧 [DEBUG MANUAL] After change event:', {
          value: actionSelect.value,
          selectedIndex: actionSelect.selectedIndex
        });
        
        // Check button state
        const generateBtn = document.getElementById('generateActionBtn');
        if (generateBtn) {
          console.log('🔧 [DEBUG MANUAL] Button state:', {
            disabled: generateBtn.disabled,
            textContent: generateBtn.textContent.trim()
          });
        }
        
        // Try to trigger generation manually
        if (generateBtn && !generateBtn.disabled) {
          console.log('🚀 [DEBUG MANUAL] Attempting to click generate button...');
          generateBtn.click();
          return true;
        } else {
          console.error('❌ [DEBUG MANUAL] Button not available for clicking');
          return false;
        }
      };

      /**
       * Check if step 2 is properly initialized and dropdown is populated
       */
              window.debugStep2Initialization = async function() {
          console.log('🔍 [DEBUG INIT] Checking step 2 initialization...');
          
          const currentStep = window.getCurrentStep();
          console.log('📍 [DEBUG INIT] Current step:', currentStep);
        
        if (currentStep !== 2) {
          console.warn('⚠️ [DEBUG INIT] Not on step 2, initialization check may not be relevant');
        }
        
        const actionSelect = document.getElementById('actionSelect');
        console.log('🔧 [DEBUG INIT] Dropdown state:', {
          exists: !!actionSelect,
          optionsCount: actionSelect ? actionSelect.options.length : 0,
          hasOptions: actionSelect ? actionSelect.options.length > 1 : false,
          currentValue: actionSelect ? actionSelect.value : null
        });
        
        if (!actionSelect) {
          console.error('❌ [DEBUG INIT] Action dropdown not found');
          return false;
        }
        
        if (actionSelect.options.length <= 1) {
          console.warn('⚠️ [DEBUG INIT] Dropdown appears empty, trying to initialize...');
          
          // Try to trigger initialization
          if (typeof window.initializeStep2ActionSelection === 'function') {
            console.log('🔧 [DEBUG INIT] Found initializeStep2ActionSelection function, calling it...');
            try {
              await window.initializeStep2ActionSelection();
              console.log('✅ [DEBUG INIT] Initialization function completed');
            } catch (error) {
              console.error('❌ [DEBUG INIT] Initialization function failed:', error);
            }
          } else {
            console.warn('⚠️ [DEBUG INIT] initializeStep2ActionSelection function not found');
          }
          
          // Check if it worked
          console.log('🔧 [DEBUG INIT] Dropdown state after initialization attempt:', {
            optionsCount: actionSelect.options.length,
            hasOptions: actionSelect.options.length > 1
          });
        }
        
        if (actionSelect.options.length > 1) {
          console.log('✅ [DEBUG INIT] Dropdown has options:', 
            Array.from(actionSelect.options).map((opt, index) => ({
              index: index,
              value: opt.value,
              text: opt.text
            }))
          );
          return true;
        } else {
          console.error('❌ [DEBUG INIT] Dropdown still empty after initialization attempts');
          return false;
        }
      };

      /**
       * Reference Images Management System
       * Handles upload, storage, and display of reference images across all steps
       */
      
      // Storage key for persistence
      const REFERENCE_IMAGES_STORAGE_KEY = 'pointer_reference_images';
      
      // Initialize reference images system
      function initReferenceImages() {
        console.log('🖼️ Initializing reference images system');
        
        // Initialize for both step 1 and step 2
        setupReferenceUpload('', '');  // Step 1
        setupReferenceUpload('2', '2'); // Step 2
        
        // Load existing images from storage
        loadReferenceImagesFromStorage();
      }
      
      /**
       * Sets up reference upload functionality for a specific step
       * @param {string} suffix - Suffix for element IDs (e.g., '2' for step 2)
       * @param {string} stepSuffix - Suffix for thumbnail container (e.g., '2' for step 2)
       */
      function setupReferenceUpload(suffix = '', stepSuffix = '') {
        const uploadArea = document.getElementById(`referenceUploadArea${suffix}`);
        const fileInput = document.getElementById(`referenceFileInput${suffix}`);
        const selectBtn = document.getElementById(`referenceSelectBtn${suffix}`);
        
        if (!uploadArea || !fileInput || !selectBtn) {
          console.warn(`⚠️ Reference upload elements not found for step ${suffix || '1'}`);
          return;
        }
        
        // File input change handler
        fileInput.addEventListener('change', (e) => {
          handleFileSelection(e.target.files);
        });
        
        // Select button click handler
        selectBtn.addEventListener('click', () => {
          fileInput.click();
        });
        
        // Upload area click handler
        uploadArea.addEventListener('click', (e) => {
          if (e.target === uploadArea || e.target.closest('.reference-upload-content')) {
            fileInput.click();
          }
        });
        
        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadArea.classList.add('drag-over');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
          e.preventDefault();
          // Only remove drag-over if we're leaving the upload area entirely
          if (!uploadArea.contains(e.relatedTarget)) {
            uploadArea.classList.remove('drag-over');
          }
        });
        
        uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('drag-over');
          
          const files = Array.from(e.dataTransfer.files).filter(file => 
            file.type.startsWith('image/')
          );
          
          if (files.length > 0) {
            handleFileSelection(files);
          }
        });
      }
      
      /**
       * Handles file selection (from input or drag-drop)
       * @param {FileList|Array} files - Selected files
       */
      function handleFileSelection(files) {
        console.log('📁 Processing reference image files:', files.length);
        
        const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
        
        if (imageFiles.length === 0) {
          alert('Please select only image files.');
          return;
        }
        
        // Process each image file
        imageFiles.forEach(file => {
          if (file.size > 10 * 1024 * 1024) { // 10MB limit
            alert(`File "${file.name}" is too large. Please select images under 10MB.`);
            return;
          }
          
          // Convert to data URL and store
          const reader = new FileReader();
          reader.onload = (e) => {
            addReferenceImage({
              id: Date.now() + Math.random().toString(36).substr(2, 9),
              name: file.name,
              dataUrl: e.target.result,
              size: file.size,
              type: file.type,
              uploadDate: new Date().toISOString()
            });
          };
          reader.readAsDataURL(file);
        });
      }
      
      /**
       * Adds a reference image to storage and displays it
       * @param {Object} imageData - Image data object
       */
      function addReferenceImage(imageData) {
        console.log('➕ Adding reference image:', imageData.name);
        
        // Get existing images from storage
        const existingImages = getReferenceImagesFromStorage();
        
        // Add new image
        existingImages.push(imageData);
        
        // Save to storage
        localStorage.setItem(REFERENCE_IMAGES_STORAGE_KEY, JSON.stringify(existingImages));
        
        // Update display in both steps
        updateReferenceImagesDisplay();
        
        console.log('✅ Reference image added and saved');
      }
      
      /**
       * Removes a reference image by ID
       * @param {string} imageId - ID of image to remove
       */
      function removeReferenceImage(imageId) {
        console.log('🗑️ Removing reference image:', imageId);
        
        const existingImages = getReferenceImagesFromStorage();
        const filteredImages = existingImages.filter(img => img.id !== imageId);
        
        // Save updated list
        localStorage.setItem(REFERENCE_IMAGES_STORAGE_KEY, JSON.stringify(filteredImages));
        
        // Update display
        updateReferenceImagesDisplay();
        
        console.log('✅ Reference image removed');
      }
      
      /**
       * Gets reference images from localStorage
       * @returns {Array} Array of image data objects
       */
      function getReferenceImagesFromStorage() {
        try {
          const stored = localStorage.getItem(REFERENCE_IMAGES_STORAGE_KEY);
          return stored ? JSON.parse(stored) : [];
        } catch (error) {
          console.error('❌ Error loading reference images from storage:', error);
          return [];
        }
      }
      
      /**
       * Loads and displays reference images from storage
       */
      function loadReferenceImagesFromStorage() {
        console.log('📁 Loading reference images from storage');
        updateReferenceImagesDisplay();
      }
      
      /**
       * Updates the display of reference images in both steps
       */
      function updateReferenceImagesDisplay() {
        const images = getReferenceImagesFromStorage();
        
        // Update step 1
        updateStepReferenceDisplay('', images);
        
        // Update step 2
        updateStepReferenceDisplay('2', images);
        
        console.log(`🖼️ Updated reference images display: ${images.length} images`);
      }
      
      /**
       * Updates reference images display for a specific step
       * @param {string} suffix - Step suffix ('' for step 1, '2' for step 2)
       * @param {Array} images - Array of image data
       */
      function updateStepReferenceDisplay(suffix, images) {
        const grid = document.getElementById(`referenceImagesGrid${suffix}`);
        const thumbnailsContainer = document.getElementById(`referenceThumbnails${suffix}`);
        const uploadArea = document.getElementById(`referenceUploadArea${suffix}`);
        
        if (!grid || !thumbnailsContainer || !uploadArea) {
          return;
        }
        
        if (images.length === 0) {
          // No images - show upload area, hide grid
          uploadArea.style.display = 'block';
          grid.style.display = 'none';
        } else {
          // Has images - show grid, hide upload area
          uploadArea.style.display = 'none';
          grid.style.display = 'block';
          
          // Clear existing thumbnails
          thumbnailsContainer.innerHTML = '';
          
          // Add thumbnails
          images.forEach(image => {
            const thumbnail = createThumbnailElement(image);
            thumbnailsContainer.appendChild(thumbnail);
          });
          
          // Add "add more" button
          const addMoreBtn = document.createElement('div');
          addMoreBtn.className = 'reference-thumbnail';
          addMoreBtn.style.border = '2px dashed var(--border-color)';
          addMoreBtn.style.display = 'flex';
          addMoreBtn.style.alignItems = 'center';
          addMoreBtn.style.justifyContent = 'center';
          addMoreBtn.style.cursor = 'pointer';
          addMoreBtn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="5" x2="12" y2="19"></line>
              <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
          `;
          addMoreBtn.title = 'Add more images';
          addMoreBtn.addEventListener('click', () => {
            document.getElementById(`referenceFileInput${suffix}`).click();
          });
          
          thumbnailsContainer.appendChild(addMoreBtn);
        }
      }
      
      /**
       * Creates a thumbnail element for an image
       * @param {Object} imageData - Image data object
       * @returns {HTMLElement} Thumbnail element
       */
      function createThumbnailElement(imageData) {
        const thumbnail = document.createElement('div');
        thumbnail.className = 'reference-thumbnail';
        thumbnail.title = imageData.name;
        
        thumbnail.innerHTML = `
          <img src="${imageData.dataUrl}" alt="${imageData.name}" />
          <button class="reference-thumbnail-remove" title="Remove image" onclick="removeReferenceImage('${imageData.id}')">
            ×
          </button>
        `;
        
        return thumbnail;
      }
      
      /**
       * Gets all reference images for use in character generation
       * @returns {Array} Array of image data URLs
       */
      function getReferenceImagesForGeneration() {
        const images = getReferenceImagesFromStorage();
        return images.map(img => img.dataUrl);
      }
      
      // Make functions globally accessible
      window.removeReferenceImage = removeReferenceImage;
      window.getReferenceImagesForGeneration = getReferenceImagesForGeneration;
      
              // Reference images will be initialized by the main DOMContentLoaded listener below
    </script>
  </body>
</html> 